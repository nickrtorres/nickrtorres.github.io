---
layout: post
title: This week I learned 15
categories: [TIL]
---

## Looking ahead

I wanted to iterate over a sequence of characters. Notably, I wanted to peek
ahead at times without advancing the iterator. The standard library has a
[`Peekable`](https://doc.rust-lang.org/std/iter/struct.Peekable.html) iterator
to look forward without advancing the iterator. Perfect.

```rust
use std::str::Chars;

struct Foo<'a> {
    chars: Chars<'a>
}

impl<'a> Foo<'a> {
    pub fn new(s: &'a str) -> Self {
        Foo { chars: s.chars() }
    }

    pub fn bar(&self) -> bool {
        if self.chars.peekable().peek().is_some() { self.baz() }
    }

    pub fn baz(&self) { self.chars.next() }

}
```

As you might imagine, this doesn't work. `peekable` takes an iterator by
`value`. `Foo::bar` takes `self` by shared reference. Hmm.

## A way out

Stepping back to the original problem:
> I wanted to peek ahead **at times**

So what I really want is an *`iterator`* that can `peek`. Sounds a lot like
`Peekable`.

Since `Peekable` is an iterator, it provides an `next`, `has_next`, etc. APIs in
addition to its '`peek` API. 
```rust
use std::str::Chars;

struct Foo<'a> {
    chars: Peekable<Chars<'a>>
}

impl<'a> Foo<'a> {
    pub fn new(s: &'a str) -> Self {
        Foo { chars: s.chars().peekable() }
    }

    pub fn bar(&self) -> bool {
        if self.chars.peek().is_some() { self.baz() }
    }

    pub fn baz(&self) { self.chars.next() }

}
```

This took me a long time (and a [half-baked reimplementation of
`Peekable`](https://github.com/nickrtorres/charstream) to figure out. I was
convinced holding a `Chars` iterator in `Foo`was the right move. 
